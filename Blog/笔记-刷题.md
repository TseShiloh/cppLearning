# 栈

## 有效的括号
1. 由于每逢右括号就要检查是否有相对应的左括号，因此采用栈的数据结构，后进先出。
2. 采用哈希表和pairs来存储括号，因为是右括号触发判断机制，因此哈希表的key值为右括号，value值为对应的左括号。
```cpp
class Solution {
public:
    bool isValid(string s) {
        if(s.size()%2 == 1) {
            return false;
        }

        //使用哈希表存储，key值为右括号，value值为对应的左括号。
        map<char,char> pairs = {
            {')', '('}, 
            {']', '['}, 
            {'}', '{'}
        };

        stack<char> stk;
        for (char ch: s) {
            if(pairs.count(ch)) { //每当遇到右括号ch，进入判断环节
                if(stk.empty() || stk.top() != pairs[ch]) {
                    return false; //若栈为空or栈顶（最近的括号）和ch不成对，则说明无效
                }                
                stk.pop(); //否则有效，出栈
            }
            else { //否则一直都是左括号，则进行入栈
                stk.push(ch);
            }
        }
        return stk.empty(); 
        //此时不为空，说明每个括号都有效；若为空，返回的0也代表false。
    }
};
```


---

## 最小栈

解法一：辅助栈
开辟两个栈，一个用于存放数据，另一个用于存放最小值。
```cpp
class MinStack {
    stack<int> x_stack; //数据栈
    stack<int> min_stack; //最小值栈
public:
    MinStack() {
        min_stack.push(INT_MAX); //默认INT_MAX = 2^31-1=2147483647
    }
    
    void push(int x) {
        x_stack.push(x);
        min_stack.push(min(min_stack.top(), x));
    }
    
    void pop() {
        x_stack.pop();
        min_stack.pop();
    }
    
    int top() {
        return x_stack.top();
    }
    
    int getMin() {
        return min_stack.top();
    }
};
```

一些疑问：
1. 能不能一个栈解决问题？
- 用pairs？本质和辅助栈一致，但时间复杂度应该会低一些
- 记录差值？
- 记录每个数据之前的差值
- 保证pop之后的最小值会实时更新

---

## 二叉树的中序遍历

1. 解法一：递归
对于每一个节点都是同一个问题，按照中序（左->根->右）遍历二叉树。
2. 解法二：迭代
主动维护了一个栈stk，因此在对数据进行操作时，先将根结点压入栈中，然后按照中序开始遍历，因此有：根结点入栈 -> （判断后）遍历左节点 -> 左节点出栈 -> 根结点出栈 -> （判断后）遍历右节点 -> 右节点出栈 -> ……
3. 解法三：Morris解法
- 能将非递归的中序遍历空间复杂度降为`O(1)`
- 假设当前遍历到的节点为x，将x的左子树中最右边的节点的右孩子指向x，这样在左子树遍历完成后我们通过这个指向走回了x，且能通过这个指向知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度。


【递归解法】
```cpp
class Solution {
public:
    void inorder(TreeNode* root, vector<int>& res) {
        if (!root) {
            return;
        }
        inorder(root->left, res);
        res.push_back(root->val);
        inorder(root->right, res);
        //以上的顺序便是“左->根->右”，利用递归实现。
    }
    vector<int> inorderTraversal (TreeNode* root) {
        vector<int> res; 
        inorder(root, res); //函数
        return res;
    }
};
```
用一个`vector<int>& res`的容器来保存遍历时的数值。注意，递归的过程其实是隐式维护了一个栈。

- 复杂度分析

时间复杂度：`O(n)`，`n`为二叉树节点的个数。

空间复杂度：`O(n)`，空间复杂度取决于递归的栈深度。


【迭代解法】
```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        while (root != nullptr || !stk.empty()) {
            while (root != nullptr) {
                stk.push(root);
                root = root->left;
            }
            root = stk.top();
            stk.pop();
            res.push_back(root->val);
            root = root->right;
        }
        return res;
    }
};
```

- 复杂度分析

时间复杂度：`O(n)`，`n`为二叉树节点的个数。

空间复杂度：`O(n)`，空间复杂度取决于栈深度，栈深度在二叉树为一条链的情况下会达到`O(n)`的级别。

【Morris解法】
能将非递归的中序遍历空间复杂度降为`O(1)`
- 假设当前遍历到的节点为x，将x的左子树中最右边的节点的右孩子指向x，这样在左子树遍历完成后我们通过这个指向走回了x，且能通过这个指向知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度。
```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        TreeNode *predecessor = nullptr;

        while (root != nullptr) {
            if (root->left != nullptr) {
                // predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止
                predecessor = root->left;
                while (predecessor->right != nullptr && predecessor->right != root) {
                    predecessor = predecessor->right;
                }
                
                // 让 predecessor 的右指针指向 root，继续遍历左子树
                if (predecessor->right == nullptr) {
                    predecessor->right = root;
                    root = root->left;
                }
                // 说明左子树已经访问完了，我们需要断开链接
                else {
                    res.push_back(root->val);
                    predecessor->right = nullptr;
                    root = root->right;
                }
            }
            // 如果没有左孩子，则直接访问右孩子
            else {
                res.push_back(root->val);
                root = root->right;
            }
        }
        return res;
    }
};
```


---

## 每日温度
1. 解法一：单调栈
当栈为空or该日温度低于栈顶温度时，则该日的日期值进栈（注意不是温度值进栈）。当遇到温度大于栈顶温度时，栈顶元素出栈，从而计算出升温的日期差。因为栈中保存的不是某日的温度，而是日期。

2. 解法二：暴力破解
反向遍历温度列表，当需要查找`i`日（此时温度为`T[i]`）之后有无**升温日**，此时只要找出最近的较高温日`next[t]`，此时温度为`t>T[i]`。如果找到了较高温日（warmerIndex != INT_MAX），就更新`warmerIndex = min(warmerIndex, next[t])`，然后计算日期差`ans[i] = warmerIndex - i`

【1.单调栈】
```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) {
        int n = T.size();
        vector<int> answer(n);
        stack<int> dayindex;
        for (int i = 0; i < n; ++i) {
            while (!dayindex.empty() && T[i] > T[dayindex.top()]) {
                int previous_dayindex = dayindex.top();
                answer[previous_dayindex] = i - previous_dayindex;
                dayindex.pop();
                }
                dayindex.push(i);
        }
        return answer;
    }
};
```

【2.暴力破解】
```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) {
        int n = T.size();
        vector<int> ans(n), next(101, INT_MAX);
        for (int i = n - 1; i >= 0; --i) { //反向遍历温度列表
            int warmerIndex = INT_MAX;
            for (int t = T[i] + 1; t <= 100; ++t) {
                warmerIndex = min(warmerIndex, next[t]); //若有温度更高的日期，将warmerIndex的值更新为新的日期
            }
            if (warmerIndex != INT_MAX) {
                ans[i] = warmerIndex - i; //计算日期差
            }
            next[T[i]] = i;
        }
        return ans;
    }
};
```


## 字符串解码
1. 解法一：栈操作

我们可以把字母、数字和括号看成是独立的 TOKEN（令牌），并用栈来维护这些 TOKEN。具体的做法是，遍历这个栈：
- 如果当前的字符为**数位**，解析出一个数字（连续的多个数位）并进栈
- 如果当前的字符为**字母**或者**左括号**，**直接进栈**
如果当前的字符为**右括号**，**开始出栈**，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字（此时栈顶一定是数字，想想为什么？），就是这个字符串应该出现的次数，我们根据这个次数和字符串构造出新的字符串并进栈
- 重复如上操作，最终将栈中的元素按照从栈底到栈顶的顺序拼接起来，就得到了答案。注意：这里可以**用不定长数组来模拟栈操作**，方便从栈底向栈顶遍历。


2. 解法二：递归

从左向右解析字符串
- 如果当前位置为**数字位**，那么后面一定包含一个用方括号表示的字符串，即`k[……]`：我们可以先解析出一个数字，然后解析到了左括号，递归向下解析后面的内容，遇到对应的右括号就返回，此时我们可以根据解析出的数字`x`解析出的括号里的字符串`s'`构造出新的字符串`x*s'`。我们把`k[……]`解析结束后，再次调用递归函数，解析右括号右边的内容。
- 如果当前位置是**字母位**，那么我们直接解析当前这个字母，然后递归向下解析这个字母后面的内容。

【栈操作】
```cpp
class Solution {
public:
    string getDigits(string &s, size_t &ptr) {
        string ret = "";
        while (isdigit(s[ptr])) {
            ret.push_back(s[ptr++]);
        }
        return ret;
    }

    string getString(vector <string> &v) {
        string ret;
        for (const auto &s: v) {
            ret += s;
        }
        return ret;
    }

    string decodeString(string s) {
        vector <string> stk;
        size_t ptr = 0;

        while (ptr < s.size()) {
            char cur = s[ptr];
            if (isdigit(cur)) { // 获取一个数字并进栈
                string digits = getDigits(s, ptr);
                stk.push_back(digits);
            } 
            else if (isalpha(cur) || cur == '[') {
                // 获取一个字母并进栈
                stk.push_back(string(1, s[ptr++])); 
            } 
            else { // cur是右括号
                ++ptr; // 先将指针后移，便于后续对 ] 之后的字符串继续进行判断和操作。
                vector <string> sub;
                while (stk.back() != "[") { //字母开始一个个出栈
                    sub.push_back(stk.back());
                    stk.pop_back();
                }
                reverse(sub.begin(), sub.end()); // 字母出栈完，反转后得到[]括号内的字符串
                stk.pop_back(); // 左括号出栈

                // 此时stk栈顶为当前sub对应的字符串应该重复的次数
                int repTime = stoi(stk.back()); 
                // stoi(字符串，起始位置，n进制(默认10进制))，将n进制的字符串转化为10进制
                stk.pop_back();
                string t, o = getString(sub); // 创建字符串t和o，初始化o作为‘被重复的字符串’
                // 构造字符串，并放入t中
                while (repTime--) t += o; 
                // 将构造好的字符串t入栈
                stk.push_back(t);
            }
        }
        return getString(stk);
    }
};
```

- 复杂度分析

记解码后得出的字符串长度为`S`

———时间复杂度：除了遍历一次原字符串`s`，解码后的字符串的每一个字符都要入栈，并最终拼接进答案中，因此时间复杂度为`O(S+|s|)`，即`O(S)`。

———空间复杂度：这里用栈维护TOKEN，栈的总大小最终与`S`相同，故渐进空间复杂度为`O(S)`

【递归】
```cpp
class Solution {
public:
    string src; 
    size_t ptr;

    int getDigits() {
        int ret = 0;
        while (ptr < src.size() && isdigit(src[ptr])) {
            ret = ret * 10 + src[ptr++] - '0'; 
            // ret*10 ：因为逐个数字判断，因此可能是十位数甚至更多位数
            // - '0' ：减去string型数字0的（ASCII码？），最终得到整型的数字
        }
        return ret;
    }

    string getString() {
        if (ptr == src.size() || src[ptr] == ']') {
            // String -> EPS
            return "";
        }

        char cur = src[ptr]; int repTime = 1;
        string ret;

        if (isdigit(cur)) {
            // String -> Digits [ String ] String
            // 解析 Digits
            repTime = getDigits(); //将左括号前的数字全找完
            ++ptr; // 过滤左括号
            string str = getString(); // 解析 String
            // 过滤右括号
            ++ptr;
            while (repTime--) ret += str; // 构造字符串
        } 
        else if (isalpha(cur)) {
            // String -> Char String
            // 解析 Char
            ret = string(1, src[ptr++]); // 生成一个字符串，包含1个src[ptr]字符
        }
        
        return ret + getString();
    }

    string decodeString(string s) {
        src = s;
        ptr = 0;
        return getString();
    }
};
```

- 复杂度分析

记解码后得出的字符串长度为`S`

———时间复杂度：除了遍历一次原字符串`s`，解码后的字符串的每一个字符都要入栈，并最终拼接进答案中，因此时间复杂度为`O(S+|s|)`，即`O(S)`。

———空间复杂度：若不考虑答案所占用的空间，那么就只剩递归使用栈空间的大小，这里**栈空间的使用**和**递归树的深度**成**正比**，最坏情况下为`O(|s|)`，故渐进空间复杂度为`O(|s|)`。

---
# 哈希表

## 两数之和
遍历每一个数组中的数据，并将他们放入哈希表。代码`hashtable[nums[i]] = i; `数组中**数据值**作为哈希表的**key值**，而需要被返回的**下标值**作为**value值**。遍历的过程中，如果没有找到满足条件的数据值则继续进行插入哈希表的操作，直到找到后移，返回满足条件的下标值。
```cpp
class Solution
{
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int>hashtable;
        for(int i = 0; i < nums.size(); ++i)
        {
            auto it  = hashtable.find(target - nums[i]);
            if(it != hashtable.end())
            {
                return{it->second, i};
            }
            hashtable[nums[i]] = i; //哈希表的key值为数据，value值为下标
        }
        return {};
    }
};
```

---
# 链表

## 合并两个有序链表
1. 解法一：递归
由于每排序出一个节点后，剩余的链表（子问题）和原问题是同一个结构，因此可以用递归法解决。

2. 解法二：迭代（暴力破解）
对比两个链表中的每一个节点，新建一个指针使其一直指向两链表中的较小值。  

【1.递归解法】
```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (l1 == nullptr) {
            return l2;
        }
        else if (l2 == nullptr) {
            return l1;
        }
        else if (l1->val < l2->val) {
            l1->next = mergeTwoLists(l1->next, l2); //递归
            return l1;
        }
        else {
            l2->next = mergeTwoLists(l1, l2->next); //递归
            return l2;
        }
    }
};
```
【2.迭代解法】
```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* ptr = new ListNode(-1) ;
        ListNode* lst = ptr;
        while (l1 != nullptr && l2 != nullptr) {
            if (l1->val < l2->val) {
                lst->next = l1;
                l1 = l1->next;
            }
            else {
                lst->next = l2;
                l2 = l2->next;
            }
            lst = lst->next;
        }
        //判断到最后，链表l1的情况只可能是 剩最后一个元素 or 已经空了
        lst-> next = (l1 == nullptr) ? l2 : l1; 
        return ptr->next;
    }
};
```



# 剑指offer

当数组作为**函数的参数**进行传递时，数组就自动退化为**同类型的指针**。
## 03.数组中重复的数字
1. 解法一：哈希表
2. 解法二：原地置换

## 03.02 不修改数组找出重复的数字
采用类似于二分法的方式，拆成两个区间进行数字数目的判断。
```cpp
int getDuplication(const int* numbers, int length)
{
    if(numbers == nullptr || length <=0) return -1;
    int start = 1;
    int end = length - 1;
    while(end >= start) {
        int middle = ((end - start) >> 1) + start; //运算符>>代表二进制右移一位，效果就是“除以2”
        int count = countRange(numbers, length, start, middle);
        if (end == start) {
            if (count > 1) 
                return start;
            else 
                break;
        }
        if (count > (middle - start + 1)) 
        //如果[start, middle]区间的实际数字数目count大于区间编号数middle-start+1，说明必然有重复数字。
        //因此缩小区间。
            end = middle; 
        else 
        //区间[middle, end]必然有重复数字
        //注意：此时区间[start, middle]其实也可能有重复数字（按下不表）
            start = middle +1;
    }
    return -1;
}

int countRange(const int* numbers, int length, int start, int end) {
    if(numbers == nullptr) 
        return 0;
    int count = 0;
    for(int i = 0; i < length; i++) {
        if (numbers[i] >= start && numbers[i] <= end) 
            ++count;
    } 
    return count;
}
```


## 04.二维数组查找
选择左下角（右上角）开始，当不满足条件时可以排除一列or一行，以此迭代。

## 05.替换空格
若是从前往后，则字符串靠后的字符都要依次向后移动两格，这样的时间复杂度是O(n^2)。
因此先遍历一次字符串检查空格数量并resize字符串，然后用两个指针分别标记原字符串的尾部和新字符串尾部，然后开始从尾部往前遍历，非空格的字符都赋值到新字符串中，空格则被替换为‘%’‘2’‘0’，调整指针位置，继续遍历，依此类推。

## 06.从尾到头打印链表
1. 解法一：反转法
2. 解法二：栈
3. 解法三：递归
4. 解法四：改变链表结构

## 07.重建二叉树
通过前序遍历找到“根结点”，再通过“根结点”将**中序遍历**分成“左子树”和“右子树”，递归此流程。
```cpp
class Solution {
private:
    vector<int> preorder;
    unordered_map<int, int>dic; //哈希表，键值为数据，数值为中序的位置
    
    TreeNode* recur(int root, int left, int right) {
        if (left > right) //当左子树边界超过右子树边界
            return nullptr;
        TreeNode* node = new TreeNode(preorder[root]);
        int i = dic[preorder[root]]; //找出某前序节点在中序的位置
        node->left = recur(root + 1, left, i - 1); //前序继续推进，通过中序确定左子树区间
        node->right = recur(root + i - left + 1, i + 1, right); //其中i-left+1是利用中序中确定右子树的相对位置，于是再加在root找到前序中的右子树位置。
        return node;
    }

public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        this->preorder = preorder;
        for (int i = 0; i < inorder.size(); i++) 
            dic[inorder[i]] = i;
        return recur(0, 0, inorder.size() - 1); //递归式子     
    }
};
```


## 08.二叉树的下一个节点
分为三种情况：
1. 如过一个节点**有右子树**，那么它的下一个节点就是它的**右子树中最左子节点**。
2. 如果一个节点**没有右子树**，……
- 它是父节点的左节点，那么下一个节点就是父节点。
- 它是父节点的右节点，那么要沿着父节点一直向上遍历，直到找到一个节点（**该节点是它父节点的左节点**），那么这个节点的**父节点**就是我们下一个节点。
```cpp
BinaryTreeNode* GetNext(BinaryTreeNode* pNode)
{
    if (pNode == nullptr)
        return nullptr;

    BinaryTreeNode* pNext = nullptr;
    if (pNode->m_pRight != nullptr) {
        BinaryTreeNode* pRight = pNode->m_pRight;
        while (pRight->m_pLeft != nullptr)
            pRight = pRight->m_pLeft;

        pNext = pRight;
    }
    else if (pNode->m_pParent != nullptr)
    {
        BinaryTreeNode* pCurrent = pNode;
        BinaryTreeNode* pParent = pNode->m_pParent;
        while (pParent != nullptr && pCurrent == pParent->m_pRight)
        {
            pCurrent = pParent;
            pParent = pParent->m_pParent;
        }
        pNext = pParent;
    }
    return pNext;
}
```

## 09.用两个栈实现队列
栈1用于push数据，当队列输出时，将栈1的数据push进栈2，然后在将栈2出栈，从而实现先进先出的规则。

## 10.斐波那契数列
- 青蛙跳台阶问题同理
  
1. 解法一：递归法
将f(n)问题的计算拆分为f(n-1)和f(n-2)两个子问题计算。但是缺点是会大量重复的递归计算，例如f(n)和f(n-1)两者向下递归需要**各自计算**f(n-2)的值。
- 如果用记忆化递归，在递归时存储f(0)至f(n)的数字值，重复遇到某数字则直接从数组取用，避免了重复的计算。
2. 解法二：动态规划
由于第i项只与第i-1项、第i-2项有关，因此只需初始化三个整型变量`sum`,`a`,`b`，利用辅助变量使得`a`,`b`两数字交替前进即可。这样就不需要用一个数组来存放前面项的值。
```cpp
class Solution {
public:
    int fib(int n) {
        int f_n = 0, f_n1 = 1, f_n2 = 0;
        if (n < 2)
            return f_n  = n;
        for (int i = 2; i <= n; i++) {
            f_n = (f_n1 + f_n2)%1000000007;
            f_n2 = f_n1;
            f_n1 = f_n;
        }
        return f_n;
    }
};
```

## 11.旋转数组的最小数字
将区间分为两个子（递增）区间，因此利用**二分法**算出`index_m`，进而将`num[index_m]`的值和`num[index1]`、`num[index2]`进行对比，从而将区间进一步缩小。
```cpp
class Solution {
public:
    int minArray(vector<int>& numbers) {
        int index1 = 0, index2 = numbers.size() - 1;
        while (index1 < index2) {
            int index_m = (index1 + index2) / 2;
            if (numbers[index_m] > numbers[index2]) 
                index1 = index_m + 1;
            else if (numbers[index_m] < numbers[index2]) 
                index2 = index_m;
            else {
                int x = index1;
                for(int k = index1 + 1; k < index2; k++) {
                    if(numbers[k] < numbers[x]) 
                        x = k;
                }
                return numbers[x];
            }
        }
        return numbers[index1];
    }
};
```

## 12.矩阵中的路径
**回溯算法**可以看作暴力解法的升级版
- 它从解决问题每一步的所有可能选项里系统地选出一个可行的解决方案。
- 回溯法非常适合解决由**多个步骤**组成的问题，而且每个步骤都有**多个选项**。
- 回溯法一般用**递归**来实现。

```cpp
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        if (word.empty())
            return false;
        for(int i = 0; i < board.size(); i++) {
            for(int j = 0; j < board[0].size(); j++) {
                if(dfs(board, word, i, j, 0)) 
                    return true;
            }
        }
        return false;
    }

    bool dfs(vector<vector<char>>& board, string& word, int i, int j, int k) {
        if (i >= board.size() || i < 0 || j >= board[0].size() 
           || j < 0 || board[i][j] != word[k]) 
            return false;
        if(k == word.size() - 1) 
            return true;
        char temp = board[i][j];
        board[i][j] = '\0';
        if (dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || 
            dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1))
            return true;
        board[i][j] = temp;
        return false;
    }
};

```


## 13.机器人的运动范围
1. 解法一：回溯算法
- 先判断机器人是否能进入(i,j)格;
- 如果能够进入(i,j)格，则再判断它能否进入4个相邻的格子;
- 即(i-1,j),(i+1,j),(i,j-1),(i,j+1)
2. 解法二：深度优先遍历DFS
- 一个方向（向下or向右）走到底再回溯
3. 解法三：广度优先遍历BFS
- “平推”方向向前搜索


【回溯算法】
```cpp
class Solution {
public:
    int movingCount(int rows, int cols, int threshold) {
        if (threshold < 0 || rows <= 0 || cols <= 0)
            return 0;
        bool* visited = new bool[rows*cols];
        for (int i = 0; i < rows*cols; ++i)
            visited[i] = false;
        int count = movingCountCore(threshold, rows, cols, 0, 0, visited);
        delete[] visited;
        return count;
    }

    int movingCountCore(int threshold, int rows, int cols, int row, int col, bool* visited) {
        int count = 0;
        if (check(threshold, rows, cols, row, col, visited)) {
            visited[row*cols + col] = true;// 定位到即将进入的格子
            //开始对格子四方的格子进行判断
            count = 1 + movingCountCore(threshold, rows, cols, row-1, col, visited)
                      + movingCountCore(threshold, rows, cols, row+1, col, visited)
                      + movingCountCore(threshold, rows, cols, row, col-1, visited)
                      + movingCountCore(threshold, rows, cols, row, col+1, visited);
        }
        return count;
    }

    //check函数：检查机器人能否进入下一个格子
    bool check(int threshold, int rows, int cols, int row, int col, bool* visited) {
        if (row >= 0 && row < rows && col >= 0 && col < cols 
            && getDigitSum(row)+getDigitSum(col) <= threshold 
            && !visited[row*cols + col])
        return true;
        return false;
    }
    
    //getDigitSum函数：记录一个数字的数位之和
    int getDigitSum(int num) {
        int sum = 0;
        while (num > 0) {
            sum += num % 10;
            num /= 10;
        }
        return sum;
    }
};
```
【DFS算法】


【BFS算法】


## 25.合并两个排序的链表
1. 解法一：迭代法
- 1.设置伪头结点dum
- 2.不断循环迭代至尾节点再做判断
2. 解法二：递归法
- 1.先判断终止条件
- 2.递归部分


【1.迭代解法】
```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* dum = new ListNode(0);
        ListNode* cur = dum;
        while (l1 != nullptr && l2 != nullptr) { //直至一个链到了尾部
            if (l1->val < l2->val) {
                cur->next = l1;
                l1 = l1->next;
            }
            else {
                cur->next = l2;
                l2 = l2->next;
            }
            cur = cur->next;
        }
        if (l1 != nullptr) cur->next = l1;
        else cur->next = l2;
        return dum->next;
    }
};
```

【2.递归解法】
```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        //递归解法
        //1. 先判断终止条件
        if (!l1 || !l2) //如果有一个链表到了尾节点
            return !l1? l2 : l1; //如果是l1到底，则返回l2；否则是l2到底，返回l1

        //2. 递归部分
        if (l1->val < l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        }
        else {
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        }
    }
};
```

## 26.树的子结构

解法：递归

建议：
1. 感觉树的很多递归题，想清楚如何分解为子问题就好做了，函数内调用递归函数不要太纠结细节，清楚函数的功能就行
2. 有时间自己还是到递归底层去看看，然后总结出递归规律方便下次用。比如这道题我的收获是：布尔类型返回值里面是递归的话，如果是或逻辑，则只要有一条路成功每层都会返回true；要想最终返回false只有所有层返回的都是false。这样可以方便以后做递归题快速构思
```cpp
class Solution {
public:
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        //函数：进行先序遍历
        return (A != NULL && B != NULL) && 
               (recur(A, B) || isSubStructure(A->left, B) || isSubStructure(A->right, B));
    }

    //函数：用于判断是否为子结构
    bool recur(TreeNode* A, TreeNode* B) {
        //终止条件
        if (B == NULL) return true;
        if (A == NULL || A->val != B->val) return false;

        //递归部分
        //A存在且A和B的值相等,则看子节点
        return recur(A->left, B->left) && recur(A->right, B->right);
    }

};
```

## 27. 二叉树的镜像

1. 解法一：递归
- 自己的收获：1.递归终止条件 2.抽象出每个子问题的共同点，即做相同操作。

2. 解法二：辅助栈
- 利用栈or队列遍历树的所有节点node，并交换每个node的左右子节点
- 1.特列处理：直接返回null
- 2.初始化：栈（或队列），加入根节点root
- 3.循环交换：当栈为空时跳出
  - 出栈：记为node
  - 添加子节点：将node左右子节点入栈
  - 交换：交换node左右子节点

【1.递归】
```cpp
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        //termination condition
        if(!root) return nullptr;
        
        //recursion
        TreeNode* temp = root->left;
        root->left = mirrorTree(root->right);
        root->right = mirrorTree(temp);
        return root;
    }
};
```

【2.辅助栈】
```cpp
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if(!root) return nullptr; //如果root为空
        stack<TreeNode*> stack;
        stack.push(root); //节点入栈
        while (!stack.empty()) {
            TreeNode* node = stack.top(); //出栈节点记为node，
            stack.pop();
            //将node的左右节点入栈
            if (node->left != nullptr) stack.push(node->left);
            if (node->right != nullptr) stack.push(node->right);
            //交换左右节点
            TreeNode* temp = node->right;
            node->right = node->left;
            node->left = temp;
        }
        return root;
        
    }
};
```

## 28. 对称的二叉树

1. 解法一：递归

- 特殊处理：若根结点`root`为空，则直接返回`true`
- 返回值：`recur(root->left, root->right)`

递归函数`recur(L, R)`
- 终止条件：
    - 当L,R同时越过叶节点：此树从顶至底的节点都对称，返回true;
    - 当L,R只有一个越过叶节点：此树不对称，返回false;
    - 当L->val ≠ R->val：此树不对称，返回false;
- 递归工作：

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        return root == nullptr? true : recur(root->left, root->right);
    }

    //function to compare
    bool recur(TreeNode* L, TreeNode* R) {
        if (L == nullptr && R == nullptr) return true;
        if (L == nullptr || R == nullptr || L->val != R->val) return false;
        return recur(L->left, R->right) && recur(L->right, R->left);
    }
};
```

## 29. 顺时针打印矩阵
1. 空值处理：返回空列表`{}`
2. 初始化：设置上下左右四个边界，和用于打印结果的列表`res`
3. 循环打印：“从左向右，从上到下，从右到左，从下到上”四个方向循环。每个方向做下面三件事情
- 根据边界打印，将元素按顺序添加到列表`res`的尾部
- 边界向内收缩1（代表已被打印）
- 判断是否打印完毕（边界是否相遇），若打印完毕则跳出
4. 返回`res`即可

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if (matrix.empty()) return {};
        vector<int> res;
        int Left = 0;                     //左边界
        int Right = matrix[0].size() - 1; //右边界
        int Top = 0;                      //上边界
        int Bottom = matrix.size() - 1;   //下边界
        while (true) {
            //Left->Right
            for (int i = Left; i <= Right; ++i) 
                res.push_back(matrix[Top][i]);
            if (++Top > Bottom) break;
            
            //Top->Bottom
            for (int i = Top; i <= Bottom; ++i)
                res.push_back(matrix[i][Right]);
            if (--Right < Left) break;

            //Right->Left
            for (int i = Right; i >= Left; --i)
                res.push_back(matrix[Bottom][i]);
            if (--Bottom < Top) break;

            //Bottom->Top
            for (int i = Bottom; i >= Top; --i)
                res.push_back(matrix[i][Left]);
            if (++Left > Right) break;
        }
        return res;
    }
};
```

## 30. 包含min函数的栈
借用辅助栈
- 数据栈：用于存储所有元素，保证函数`push` `pop` `top`的正常逻辑
- 辅助栈：存储数据栈中所有**非严格降序**的元素，数据栈中的最小元素始终对应辅助栈中的栈顶元素，即`min()`函数只需返回辅助栈的栈顶元素即可
```cpp
class MinStack {
public:
    stack<int> A, B;

    void push(int x) {
        A.push(x);
        if (B.empty() || x <= B.top()) //避免有重复的最小值
            B.push(x);
    }
    
    void pop() {
        if (B.top() == A.top())
            B.pop();
        A.pop();
    }
    
    int top() {
        return A.top();
    }
    
    int min() {
        return B.top();
    }
};
```

## 31. 栈的压入/弹出序列

1. 将[压入序列]不断和[弹出队列]比较，遇到相同的则[压入序列]的元素出栈；不等则继续执行[压入序列]的进栈操作
2. 简言之，就是循环拿[弹出队列]去遍历[压入序列]的栈顶元素。

```cpp
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        stack<int> mystack;
        int i = 0;
        for (int num:pushed) {
            mystack.push(num); // num入栈
            while (!mystack.empty() && mystack.top() == popped[i]) {
                // 循环跟出栈序列比较，如果对上了出栈序列的数则进入如判断
                mystack.pop();// 对上了则入栈序列的该数可以剔除
                i++;// 然后和出栈序列比较下一个数字
            }
        }
        return mystack.empty();// 全部对上了则栈会为空，否则说明没有对上。
    }
};
```

## 32. 从上到下打印二叉树

【1.从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印】
```cpp
class Solution {
public:
    vector<int> levelOrder(TreeNode* root) {
        // 实现层序遍历
        vector<int> ans;
        if (!root) return ans;
        queue<TreeNode*> myqueue;
        myqueue.push(root);
        while (myqueue.size()) {
            TreeNode* node = myqueue.front();
            myqueue.pop();
            ans.push_back(node->val);
            if(node->left) myqueue.push(node->left);// 如果有左子节点，则加入队列
            if(node->right) myqueue.push(node->right);// 如果有右子节点，则加入队列
        }
        return ans;
    }  
};
```

【2.每一层打印到一行】
```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        if (!root) return ans;
        queue<TreeNode*> Myq;
        Myq.push(root);
        while (!Myq.empty()) {
            vector<int> temp;
            for (int i = Myq.size(); i>0; i--) {
            // i初始化为队列的长度（而不是0），避免循环中队列的长度发生变化
                TreeNode* node = Myq.front();
                Myq.pop();
                temp.push_back(node->val);
                if (node->left) Myq.push(node->left);// 添加左右子节点时，此时队列可能发生变化
                if (node->right) Myq.push(node->right);
            }
            ans.push_back(temp);
        }
        return ans;
    }
};
```

【3.打印顺序交替变化】

方法：层序遍历+双端队列（奇偶层逻辑分离）
- 奇数层，则添加至队列尾部
- 偶数层，则添加至队列头部

**时间复杂度** *O(N)*：N为二叉树的节点数量，即BFS需要循环N次，占用O(N)；双端队列的队首和队尾的添加和删除操作的时间复杂度均为O(1)；
**空间复杂度** *O(N)*：最差的情况下树是满二叉树时，最多有N/2个树节点同时在deque中，使用O(N)大小的额外空间。

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        if (!root) return ans;
        deque<TreeNode*> Myq;
        Myq.push_front(root);
        while (!Myq.empty()) {
            vector<int> temp;
            for (int i = Myq.size(); i>0 ;i--) {
                TreeNode* node = Myq.front();
                Myq.pop_front();
                temp.push_back(node->val);
                if (node->left) Myq.push_back(node->left);
                if (node->right) Myq.push_back(node->right);
            }
            ans.push_back(temp);
            if (Myq.empty()) break;// 如果此时已经空了，就提前跳出
            temp.clear();
            for (int i = Myq.size(); i>0 ;i--) {
                TreeNode* node = Myq.back();
                Myq.pop_back();
                temp.push_back(node->val);
                if (node->right) Myq.push_front(node->right);
                if (node->left) Myq.push_front(node->left);
            }
            ans.push_back(temp);
        }
        return ans;
    }
};
```


## 33. 二叉搜索树的后序遍历序列

后序遍历：左右根
二叉搜索树：左子树所有节点<根结点；右子树所有节点>根结点

1. 解法一：递归分治
判断所有子树的正确性
- **终止条件**：当遍历起点i超过终点j，说明此子树节点数量≤1，无需判断正确性，因此直接true；
- **递推工作**：
    1. 划分左右子树：遍历后序遍历的[i ,j]区间元素，寻找**第一个大于根节点**标记为`mid`。可划分出左子树区间[i, mid-1]、右子树区间[mid, j-1]、根节点索引j。
    2. 判断是否为二叉搜索树：
       - **左子树区间**[i, mid-1]内的所有节点都 < `postorder[j]`。这一步骤在第一步划分左右子树时已经保证了左子树区间的正确性，因此只需要判断右子树区间的正确性就行。
       - **右子树区间**[mid, j-1]内的所有节点都 > `postorder[j]`。遇到≤ `postorder[j]`的节点则跳出；然后通过`p=j`是否为二叉搜索树（如果此时哨兵p不是根结点j，返回false）
- **返回值**：所有字数都需正确才可判定正确，因此使用**与逻辑符**&&连接。
  1. p=j 判断**此树**是否正确
  2. recur(i ,m-1) 判断此树的**左子树**
  3. recur(m ,j-1) 判断此树的**右子树**


**时间复杂度***O(N^2^)*：每次调用recur(i,j)减去一个根结点，因此递归占用*O(N)*;最差情况下，树退化成链表，每轮递归都需要遍历树的所有节点，占用*O(N)*
**空间复杂度***O(N)*：最差情况下，树退化成链表，递归深度达到*N*

---

2. 解法二：辅助单调栈
后序遍历倒序，即：根->右->左

**见题解**

**时间复杂度***O(N)*：遍历postorder所有节点，各节点均入栈/出栈一次，使用*O(N)*时间。
**空间复杂度***O(N)*：最差情况下，树退化成链表，单调栈stack存储所有节点，使用*O(N)*额外空间。

---

【1.递归】
```cpp
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        return recur(postorder, 0, postorder.size() - 1);
    }
    
    bool recur(vector<int>& postorder, int start, int end) {
        if (start >= end) return true;// 当起始点i超过终点j，意味着遍历结束
        int pointer = start;// 初始化哨兵pointer
        while (postorder[pointer] < postorder[end]) pointer++;
        int mid = pointer;
        while (postorder[pointer] > postorder[end]) pointer++;
        return pointer == end && recur(postorder, start, mid - 1) && recur(postorder, mid, end -1);
    }
};
// 由于是二叉搜索树的后序遍历，因此根结点一定是序列中的最后一位，即postorder[j]
```


【2.辅助栈】
```cpp
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        stack<int> MyStack;
        int root = INT_MAX;// 初试根结点为正无穷大，把树的根看成是这个初试结点的左孩子
        for (int i = postorder.size() - 1; i >= 0; i--) {// 后序遍历的倒序：根->右->左
            if (postorder[i] > root) return false;
            while(!MyStack.empty() && MyStack.top() > postorder[i]) {
                // 找一个大于postorder[i]但同时差距最小的，就是postorder[i]的父结点
                root = MyStack.top();
                MyStack.pop();
            }
            MyStack.push(postorder[i]);
        }
        return true;
    }
};
```

## 34. 二叉树中和为某一值的路径

- 先序遍历：由于是从根结点出发，所以选定先序遍历（根->左->右）
- 路径记录：在前序遍历中，记录从根节点到当前节点的路径。如果满足下面两点则将此路径加入到结果列表
    1. 根节点到叶节点形成的路径
    2. 各节点值的和等于目标值

1. 函数`pathSum(root, sum)`
- **初始化**：结果列表`res`，路径列表`path`
- **返回值**：`res`

2. 函数`recur(root, tar)`
- **递推参数**：当前节点`root`，当前目标值`tar`
- **终止条件**：若节点`root`为空（已经到了叶节点），则直接返回
- **递推工作**：
    1. 路径更新：将当前节点值`root->val`加入到路径`path`
    2. 目标值更新：`tar` = `tar` - `root->val`（即目标值从sum减到0）
    3. 路径记录：当`root`为叶节点**且**路径和等于目标值，当前`path`加入`res`集合中
    4. 先序遍历：递归左/右子节点
    5. 路径恢复：向上回溯前，需要将当前节点从路径`path`中删除，即执行`path.pop()`


**时间复杂度***O(N)*：*N*为二叉树的节点数，先序遍历需要遍历所有节点
**空间复杂度***O(N)*：最差情况下，树退化成链表，`path`存储所有节点，使用*O(N)*额外空间。

【1.回溯法】
```cpp
class Solution {
public:
    vector<vector<int>> res;// 满足条件的路径集合
    vector<int> path;// 记录当前路径
    vector<vector<int>> pathSum(TreeNode* root, int target) {
        recur(root, target);
        return res;
    }
    void recur(TreeNode* root, int tar) {
        if (!root) return;
        path.push_back(root->val);
        tar -= root->val;
        if (tar==0 && !root->left && !root->right)// 当root为叶节点且路径和等于目标值
            res.push_back(path);// 当前path加入res集合中
        recur(root->left, tar);// 递归左/右子节点
        recur(root->right, tar);
        path.pop_back();// 向上回溯，将当前节点从path中删除
    }
};
```

## 35. 复杂链表的复制

```cpp
class Solution {
public:
    Node* copyRandomList(Node* head) {
        Node* cur = head;                      // cur作为旧链表的哨兵
        Node* dum = new Node(0), *pre = dum;   // 新链表pre,伪头结点dum
        while (cur != nullptr) {
            Node* node = new Node(cur->val);   // node将旧链表的值保存下来
            pre->next = node;                  // 将值赋给新链表
            // pre->random = ???               // 无法确定新链表的random指向
            cur = cur->next;                   // 更新旧链表哨兵
            pre = node;                        // 更新新链表
        }
        return dum->next;
    }
};
```

- 复制普通链表只需遍历链表，每轮建立节点+构建前驱结点`pre`和当前节点`node`的引用指针即可。
- 本题链表的节点新增了`random`指针，指向链表中的**任意节点**或者`null`。这个`random`指针意味着在复制过程中，除了构建前驱节点和当前节点的引用指向`pre.next`，还要构建前驱节点和其随机节点的引用指向`pre.random`。



1. 解法一： 哈希表

利用哈希表构建**原链表节点**和**新链表对应节点**的==键值对映射关系==，再遍历构建新链表各节点的`next`和`random`引用指向即可。

- **时间复杂度***O(N)*：两轮遍历链表，使用*O(N)*时间
- **空间复杂度***O(N)*：哈希表`dic`使用线性大小的额外空间


2. 解法二：拼接+拆分（空间复杂度更低）

考虑构建[原节点1->新节点1->原节点2->新节点2->……]的拼接链表，如此便可以在访问原节点的`random`指向节点的同时找到新对应新节点的`random`指向节点

   1. 复制各节点，构建拼接链表（原节点->新节点->……）
   2. 构建新链表各节点的`random`指向
      - 当访问原节点`cur`的`cur->random`时，对应新节点`cur->next`的随机指向节点为`cur->random->next`
   3. 拆分链表为：原、新
   4. 返回新链表的头节点`res`

- **时间复杂度***O(N)*：三轮遍历链表，使用*O(N)*时间
- **空间复杂度***O(1)*：节点引用变量使用常数大小的额外空间


【1.哈希表】
```cpp
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (head == nullptr) return nullptr;
        Node* cur = head;                      // cur作为旧链表的哨兵
        unordered_map<Node* ,Node*> MyMap;     // 建立“原节点->新节点”的映射关系
        while (cur != nullptr) {
            MyMap[cur] = new Node(cur->val);
            cur = cur->next;
        }
        cur = head;                            // 第一遍循环结束，映射工作已完成；准备第二遍循环
        while (cur != nullptr) {               // 构建新链表的next和random指向
            MyMap[cur]->next = MyMap[cur->next];
            MyMap[cur]->random = MyMap[cur->random];
            cur = cur->next;
        }
        return MyMap[head];                    // 返回新链表的头结点
    }
};
```


【2.拼接+拆分】
```cpp
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (head == nullptr) return nullptr;
        Node* cur = head;                       // cur作为旧链表的哨兵
        while (cur != nullptr) {
            Node* temp = new Node(cur->val);     // 复制当前节点
            temp->next = cur->next;             // 复制next节点
            cur->next = temp;                   // 使[旧节点->新节点]
            cur = temp->next;                   // 更新哨兵，指向下一个旧节点
        }                                       
        cur = head;                             // 第一遍循环结束，开启第二次循环
        while (cur != nullptr) {                
            if (cur->random != nullptr)       // 构建新节点的random指向
                cur->next->random = cur->random->next;
            cur = cur->next->next;              // 更新cur：旧链的下一个节点    
        }                                       // 第二次循环结束，新链的random更新完毕
        cur = head->next;                       // 哨兵指向新链的头节点
        Node* pre = head, *res = head->next;    // res指向新链的头节点
        while (cur->next != nullptr) {
            pre->next = pre->next->next;        // 将旧节点单独成链
            cur->next = cur->next->next;        // 将新节点单独成链
            pre = pre->next;                    // 跳转下一个旧链节点
            cur = cur->next;                    // 跳转下一个新链节点
        }
        pre->next = nullptr;                    // 单独处理旧链的表尾节点
        return res;                             // 返回新链的表头
    }
};
```

## 36. 二叉搜索树与双向链表


需要完成的三个要素：
- 排序链表：节点从小到大，利用性质（二叉搜索树的中序遍历时**递增序列**）
- 双向链表：在构建相邻节点的引用关系时，设前驱结点`pre`和当前节点`cur`
- 循环链表：设置链表头尾节点`head`,`tail`。构建`head->left = tail`和`tail->right = head`


一、递归法中序遍历`dfs(cur)`
1. **终止条件**：当节点cur为空，代表越过叶节点，直接返回；
2. **递归左子树**，即`dfs(cur->left)`；
3. **构建链表**：
   1. 当`pre`为空时：说明正在访问链表的头节点，记为head
   2. 当`pre`不为空时：修改双向节点引用，即`pre->right=cur`，`cur->left=pre`;
   3. 保存`cur`：更新`pre=cur`，即节点`cur`是后续节点的`pre`
4. **递归右子树**，即`dfs(cur->right)`；


二、主函数`treeToDoublyList(root)`
1. 特例处理：若节点`root`为空，则直接返回；
2. 初始化：空节点`pre`（前驱节点）
3. 转化为双向链表：调用`dfs(root)`函数；
4. 构建循环链表：中序遍历完成后，`head->left=pre`和`pre->right=head`构成循环
5. 返回值：返回链表的头节点`head`即可；


- **时间复杂度***O(N)*：*N*为二叉树的节点数，中序遍历需要访问所有节点
- **空间复杂度***O(N)*：最差情况下，树退化成链表时，递归深度达到*N*，系统使用*O(N)*栈空间


```cpp
class Solution {
private:
    Node* pre, *head;                // head是链表头，pre是前驱节点
    void dfs(Node* cur) {
        if (cur == nullptr) return;  // 到达叶子节点
        dfs(cur->left);              // 进行中序遍历    
        if (pre != nullptr) 
            pre->right = cur;        // 若不是链表的头结点，则构建[前驱->后继]
        else 
            head = cur;              // 若为链表的头结点，则cur作为头节点 
        cur->left = pre;             // 构建[后继->前驱]
        pre = cur;                   // 更新pre，当前节点变为前驱节点
        dfs(cur->right);             // 进行中序遍历
    }
    
public:
    Node* treeToDoublyList(Node* root) {
        if (root == nullptr)
            return nullptr;
        dfs(root);
        head->left = pre;            // 此时pre和cur都指向就是链表尾节点
        pre->right = head;           // 构建头尾的双向链表（即循环链表）
        return head;
    }
};
```

## 37. 序列化二叉树

- 前中后序三种方式遍历的二叉树信息不完整，一个输出序列可能对应着多种二叉树。
- 因此考虑将叶节点下的null也记录。在此基础上，对于列表中任意某结点`node`，其左子节点`node->left`和右子节点`node->right`在序列中的位置都是**唯一确定**的。
- 采用层序遍历BFS

【序列化】
借助队列，对二叉树做层序遍历，并把越过叶节点的`null`也打印出来

1. **特例处理**：若`root`为空，直接返回空列表[];
2. **初始化**：队列`queue`（包含根结点`root`）；序列化列表`ans`
3. **层序遍历**：
   1. 节点出队列，记为`node`
   2. 若`node`不为空，打印字符串`node->val`，将左右子节点加入队列`queue`
   3. 若node为空，打印字符串null
4. **返回值**：拼接列表，用`,`隔开，首尾添加中括号；


- **时间复杂度***O(N)*：*N*为二叉树的节点数，层序遍历需要访问所有节点，最差的情况下需要访问到*N+1*个null，总体复杂度为*O(2N+1)=O(N)*
- **空间复杂度***O(N)*：最差情况下，队列queue同时存储 *(N+1)/2* 个节点（或*N+1*个null），使用*O(N)*；列表`res`使用*O(N)*。



【反序列化】
利用队列按层构建二叉树，借助一个指针i指向节点`node`的左、右子节点，每构建一个`node`的左、右子节点，指针i就向右移动1位。

1. **特例处理**：若`data`为空，直接返回空列表null;
2. **初始化**：序列化列表`vals`(先去掉首尾中括号，再用逗号隔开)，指针`i=1`，根节点`root`（值为`vals[0]`），队列`queue`（包含`root`）
3. **按层构建**：当`queue`为空时跳出
   1. 节点出队列，记为`node`；
   2. 构建`node`的左子节点：`node->left`的值为`vals[i]`，并将`node->left`入队；
   3. 执行`i += 1`；
   4. 构建`node`的右子节点：`node->right`的值为`vals[i]`，并将`node->right`入队；
   5. 执行`i += 1`；
4. **返回值**：返回根节点`root`即可


- **时间复杂度***O(N)*：*N*为二叉树的节点数，按层构建二叉树需要遍历整个`vals`，其长度最大为*2N+1*
- **空间复杂度***O(N)*：最差情况下，队列`queue`同时存储 *(N+1)/2* 个节点，因此使用*O(N)*额外空间。


```cpp
class Codec {
public:
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if (root == nullptr)                            // 树为空，返回空字符串
            return "[]";
        string ans ="[";                                // 初始化用于输出的字符串ans
        queue<TreeNode*> Myq;
        Myq.push(root);
        while (!Myq.empty()) {
            TreeNode* node = Myq.front();
            Myq.pop();
            if (node != nullptr) {                      // 如果该节点不为空
                ans += (to_string(node->val) + ",");    // 将该节点加入输出结果的字符串
                Myq.push(node->left);                   // 将左右子节点加入队列
                Myq.push(node->right);                  // 将左右子节点加入队列
            }
            else                                        // 如果该节点为空
                ans += "null,";                         // 则输出字符串null
        }
        ans.erase(ans.length()-1, 1);                   // 将字符串吧最后多出来","去掉；
        ans += "]";                                     // 完成[树->字符串]的转换
        return ans;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if (data == "[]")                                       // 空字符串，则无树
            return NULL;
        stringstream iss(data.substr(1, data.length()-2));      // 去掉字符串的[]
        string str;
        getline(iss,str,',');                                   // 取子串，逢‘,’就停
        TreeNode* root = new TreeNode(atoi(str.c_str()));       // 将第一个数据作为树根root
        queue<TreeNode*> Myq;                                    
        Myq.push(root);                                            
        while (!Myq.empty()) {                                  // DFS
            TreeNode* node = Myq.front();                       // 将node作为某子树的树根
            Myq.pop();
            getline(iss,str,',');                               // 获取下一个字符串
            if (str != "null") {
                node->left = new TreeNode(atoi(str.c_str()));   // 将左子节点加入队列
                Myq.push(node->left);
            }
            getline(iss,str,',');                               // 获取下一个字符串
            if (str != "null") {
                node->right = new TreeNode(atoi(str.c_str()));  // 将右子节点加入队列
                Myq.push(node->right);
            }
        }
        return root;
    }

};
```

补充知识：
1. geline()
   - 在< **istream** >有两种重载形式；从istream中读取至多`n`个字符(包含结束标记符)保存在`s`对应的数组中。如果还没读够`n`个字符，但是遇到`delim`或**字数达到限制**，则读取终止，`delim`及其之后的字符串都不会被保存进`s`对应的数组中。
   - 在< **string** >中有四种重载形式；`is`表示一个输入流，例如 cin。`str`是string类型的引用，用来存储输入流中的流信息。`delim`是char类型的变量，是设置的截断字符，在不自定义设置的情况下，遇到’\n’，则终止输入。此处的用法和上一种类似，但是读取的istream是作为参数`is`传进函数的。读取的字符串保存在string类型的`str`中。


```cpp
//<istream>
istream& getline (char* s, streamsize n);
istream& getline (char* s, streamsize n, char delim);

//<string>
istream& getline (istream&  is, string& str, char delim);
istream& getline (istream&& is, string& str, char delim);
istream& getline (istream&  is, string& str);
istream& getline (istream&& is, string& str);
```

2. stringstream
   - 基于`stringstreambase`，需要包括头文件<**sstream.h**>
   - 用于Cpp风格的字符串输入输出
   - 可以实现数据类型转换、以**空格**分割的字符串的切分（默认为空格，可自定义）


## 38. xxxx

## 45. 把数组排成最小的数
自定义排序的规则（拼接后的数值大小），将数字排序。
【排序判断规则】
- 若拼接字符串x + y > y + x，则x“大于”y
- 反之，若x + y < y + x，则x“小于”y

根据以上规则，套用任何排序方法对nums执行排序即可。

算法流程：
1. **初始化**：字符串列表strs，保存各个数字的字符串格式；
2. **列表排序**：应用自定义的排序规则对strs进行排序
3. **返回值**：拼接strs中所有的字符串并返回

**时间复杂度***O(NlogN)*：*N*为为最终返回值的字符数量（strs列表的长度<=*N*）；使用**快排**或**内置函数**的平均时间复杂度为*O(NlogN)*，最差为*O(N^2^)*
**空间复杂度***O(N)*：字符串列表strs占用线性大小的额外空间

```cpp
class Solution {
public:
    string minNumber(vector<int>& nums) {
        vector<string> strs;
        for (int i = 0; i < nums.size(); i++)
            strs.push_back(to_string(nums[i]));
        quickSort(strs, 0, strs.size() - 1);
        string res;
        for (string s : strs)
            res.append(s);
        return res;
    }
private:
    // 自定义快排
    void quickSort(vector<string>& strs, int left, int right) {
        if (left >= right)
            return;
        int i = left, j = right;
        while (i < j) {
            while(strs[j] + strs[left] >= strs[left] + strs[j] && i < j)
                j--;
            while(strs[i] + strs[left] <= strs[left] + strs[i] && i < j)
                i++;
            swap(strs[i], strs[j]);
        }
        swap(strs[i], strs[left]);
        quickSort(strs, left, i-1);
        quickSort(strs, i+1, right);
        
    }
};
```

## 46. 把数字翻译成字符串
1. 解法一：动态规划
- **状态定义**：动态规划列表`dp`，`dp[i]`代表以x~i~为结尾的数字的翻译方案
- **转移方程**：若x~i~和x~i-1~组成的两位数可以被翻译，则`dp[i]=dp[i-1]+dp[i-2]`；反之，`dp[i]=dp[i-1]`
- **初始状态**：`dp[0]=dp[1]=1`，即“无数字”和“一位数字”的翻译方法数量均为1；
- **返回值**：`dp[n]`，即此数字的翻译方案数量

**时间复杂度***O(N)*：*N*为字符串s的长度（即数字num的位数log(num)），这决定了循环次数
**空间复杂度***O(N)*：字符串s使用*O(N)*大小的额外空间



2. 解法二：数字求余
优化了空间复杂度

- 利用求余运算`num%10`和求整运算`num//10`，可获取数字`num`的各位数字（获取顺序为个位、十位、百位…）。
- 因此，可通过 **求余** 和 **求整** 运算实现 **从右向左** 的遍历计算。
- 自此，字符串s的空间占用也被省去，空间复杂度从*O(N)*降至*O(1)*。

**时间复杂度***O(N)*：*N*为字符串s的长度（即数字num的位数log(num)），这决定了循环次数
**空间复杂度***O(1)*：几个变量使用常数大小的额外空间




【1. 字符串遍历】
```cpp
class Solution {
public:
    int translateNum(int num) {
       string s = to_string(num);
       int dp_i = 1, dp_i_1 = 1;
       for (int i = 2; i <= s.size(); i++) {
           string t = s.substr(i-2, 2);// 用t存储长度为2的子串
           int c = (stoi(t) >= 10 && stoi(t) <= 25) ? dp_i + dp_i_1 : dp_i;
           dp_i_1 = dp_i;
           dp_i = c;
        }
       return dp_i;
    }
};
```

【2. 数字求余】
```cpp
class Solution {
public:
    int translateNum(int num) {
       string s = to_string(num);
       int dp_i = 1, dp_i_1 = 1;
       int x, y = num % 10;
       while (num != 0) {
           num /= 10;
           x = num % 10;
           int temp = 10 * x + y;
           int c = (temp >= 10 && temp <= 25) ? dp_i + dp_i_1 : dp_i;
           dp_i_1 = dp_i;
           dp_i = c;
           y = x;
        }
       return dp_i;
    }
};
```

## 47. 礼物的最大价值
动态规划：
- **状态定义**：设动态规划矩阵dp,dp(i,j)代表从棋盘的左上角开始，到达单元格(i,j)时能拿到礼物的最大累积价值
- **转移方程**：
    1. 当i=0且j=0时，为其实元素；
    2. 当i=0且j≠0时，为矩阵第一行元素，只能从左边到达；
    3. 当i≠0且j=0时，为矩阵第一列元素，只能从上边到达；
    4. 当i≠0且j≠0时，可以从左边or上边到达；
- **初始状态**：`dp[0][0]=grid[0][0]`，即到达单元格（0,0）是能拿到礼物的最大累积价值为`grid[0][0]`；
- **返回值**：`dp[m-1][n-1]`，m，n分别为矩阵的行高和列宽，即返回dp矩阵右下角元素。


**时间复杂度***O(MN)*：*M*，*N*分别为矩阵行高、列宽；动态规划需遍历整个grid矩阵。
**空间复杂度***O(1)*：原地修改使用常数大小的额外空间


```cpp
class Solution {
public:
    int maxValue(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        for (int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if (i == 0 && j == 0) 
                    continue;
                if (i == 0) 
                    grid[i][j] += grid[i][j-1];// 为矩阵第一行元素，只可从左边到达
                else if (j == 0) 
                    grid[i][j] += grid[i-1][j];// 为矩阵第一列元素，只可从上边到达
                else
                    grid[i][j] += max(grid[i][j-1], grid[i-1][j]);
            }
        }
        return grid[m-1][n-1];
    }
};
```

## 48. 最长不含重复字符的子字符串
动态规划：
- **状态定义**：设动态规划矩阵`dp`,`dp[j]`代表以字符`s[j]`为结尾的“最长不重复字符串”的长度
- **转移方程**：固定右边界j，设字符`s[j]`左边距离最近的相同字符为`s[i]`，即`s[i]` = `s[j]`
    1. 当i<0，即`s[j]`左边没有相同字符，则`dp[j]=dp[j-1]+1`
    2. 当`dp[j-1] < j-i`，说明`s[j]`在子串之外，因此要`dp[j] = dp[j-1]+1`；
    3. 当`dp[j-1] >= j-i`，说明`s[j]`在子串中出现过，因此`dp[j]`的左边界由`s[i]`决定，即`dp[j]=j-i`
- **返回值**：`max(dp)`，即全局的“最长不重复字符串”的长度

1. 解法一：动态规划+哈希表
   
- 哈希表统计：遍历字符串s时，使用哈希表统计 **各字符最后一次出现的索引位置**
- 左边界i获取方式：遍历到`s[j]`时，可通过访问哈希表获取最近的相同字符的索引i


**时间复杂度***O(N)*：其中*N*为字符串长度，动态规划需遍历计算dp列表。
**空间复杂度***O(1)*：字符的ASCII码范围为0~127，哈希表最多使用*O(128)=O(1)*大小的额外空间。

2. 解法二：动态规划+线性遍历

- 左边界i获取方式：遍历到`s[j]`时，初始化索引`i=j−1`，向左遍历搜索第一个满足`s[i]=s[j]`的字符即可。  

**时间复杂度***O(N^2^)*：其中*N*为字符串长度，动态规划需遍历计算dp列表，占用*O(N)*；每轮计算dp[j]时搜索i需要遍历j个字符，占用*O(N)*
**空间复杂度***O(1)*：几个变量使用常数大小的额外空间

3. 解法三：双指针+哈希表

- 哈希表统计：遍历字符串s时，使用哈希表统计 **各字符最后一次出现的索引位置**
- 更新左指针i：根据上轮左指针`i`和`dic[s[j]]`，每轮更新左边界`i`，保证区间[i+1, j]内无重复字符且最大。`i=max(dic[s[j]],i)`
- 更新结果res：取上轮res和本轮双指针区间[i+1, j]的宽度（j-i）的最大值。`res=max(res, j-i)`


**时间复杂度***O(N)*：其中*N*为字符串长度，动态规划需遍历计算dp列表。
**空间复杂度***O(1)*：字符的ASCII码范围为0~127，哈希表最多使用*O(128)=O(1)*大小的额外空间。

```cpp
class Solution {
public:
    // 动态规划空间优化
int lengthOfLongestSubstring(string s)
{
    // <s[i] 左边与其最近的相同字符, 索引>
    unordered_map<char, int> mapping;
    int n = s.size();
    int dp = 0;
    int res = 0;
    for(int i = 0; i < n; i++)
    {
        int j = mapping.count(s[i]) ? mapping[s[i]] : -1;
        mapping[s[i]] = i;
        dp = i - j > dp ? 1 + dp : i - j;// 判断相同字符之间的距离
        res = max(res, dp);
    }
    return res;
}
};
```


## 49. 丑数

- **状态定义**：设动态规划列表`dp`，`dp[i]`代表第i+1个丑数
- **转移方程**：
    1. 当索引a,b,c满足以下条件时，`dp[i]`为三种情况的最小值；
    2. 每轮计算`dp[i]`后，需要更新索引a,b,c的值，使其始终满足方程条件。实现方法：分别独立判断`dp[i]`和`dp[a]*2`、`dp[b]*3`、`dp[c]*5`的大小关系，若相等则将对应索引a,b,c加1；
    3. `dp[i] = min(dp[a]*2, dp[b]*3, dp[c]*5)`

- **初始状态**：`dp[0]=1`，即第一个丑数为1
- **返回值**：`dp[n-1]`,即返回第n个丑数

**时间复杂度***O(N)*：其中*N=n*，动态规划需遍历计算dp列表。
**空间复杂度***O(N)*：长度为*N*的dp列表使用*O(N)*的额外空间。


```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        int multi_2 = 0, multi_3 = 0, multi_5 = 0;// 三个指针，分别对应要乘以2，3，5的数。
        int dp[n];
        dp[0] = 1;
        for (int i = 1; i < n; i++) {
            int n2 = dp[multi_2]*2, n3 = dp[multi_3]*3, n5 = dp[multi_5]*5;
            dp[i] = min(min(n2, n3), n5);
            if (dp[i] == n2) multi_2++;
            if (dp[i] == n3) multi_3++;
            if (dp[i] == n5) multi_5++;
        }
        return dp[n-1];
    }
};
```

## 50. 第一个只出现一次的字符
1. 解法一：哈希表
- 遍历字符串s，使用哈希表统计“各字符数量是否>1”
- 再遍历字符串s，在哈希表汇总找到“数量为1的字符”，并返回

    1. 初始化：建立哈希表
    2. 字符统计：遍历字符串s的每个字符c
       - 若dic中 **不包含** key键值c：则向dic中添加键值对`(c, true)`，代表字符c的数量为1；
       - 若dic中 **包含** key键值c：则向dic中添加键值对`(c, false)`，代表字符c的数量> 1；
    3. 查找数量为1的字符：遍历字符串s中的每个字符c；
       - 若dic中键值c对应的值为`true`，则返回c
    4. 返回`' '`，代表字符串中无<出现次数为1>的字符

2. 解法二：有序哈希表
- 有序哈希表中的键值对时按照插入顺序排序的
- 因此通过遍历有序哈希表实现搜索首个“数量为1的字符”

**时间复杂度***O(N)*：*N*为字符串s的长度；需要遍历s两轮，使用*O(N)*；HashMap查找操作的复杂度*O(1)*
**空间复杂度***O(1)*：s只包含小写字母，因此最多有26个不同字符，HashMap存储需占用的*O(26)* = *O(1)*额外空间。


```cpp
class Solution {
public:
    char firstUniqChar(string s) {
        vector<char> keys;
        unordered_map<char, bool> dic;          // key为字符，value为是否<只出现了一次>
        for (char c:s) {
            if (dic.find(c) == dic.end())       // 如果没有找到字符c
                keys.push_back(c);              // 说明还没出现过，则加入到keys                
            dic[c] = (dic.find(c) == dic.end());// 找到了字符c则说明已经出现过了，置为false
        }
        for (char c : keys) {
            if (dic[c])                         // 找第一个<只出现一次>的字符
                return c;
        }
        return ' ';
    }
};
```

## 51. 数组中的逆序对
归并排序、分治思想
- **分**：不断将数组从中点位置划分开（即二分法），将整个数组的排序问题转换为子数组的排序问题
- **治**:划分到子数组长度为1时，开始向上合并，不断将 **较短排序树组** 合并为 **较长排序树组**，直至合并为原数组时完成排序。

归并排序与逆序对统计：
1. **终止条件**：当l>=r时，代表子数组长度为1，此时终止划分；
2. **递归划分**：计算数组中点m，递归划分左子数组`merge_sort(left, mid)` 和右子数组 `merge_sort(mid+1, right)`；
3. **合并与逆序对统计**：
   1. 暂存数组nums闭区间[i, r]内的元素到辅助数组temp
   2. **循环合并**： 设置双指针i,j分别指向左/右子数组的首元素；
        - 当i=m+1时：代表左子数组已合并完，因此添加右子数组当前元素temp[j]，并执行j=j+1；
        - 否则，当j=right+1时：代表右子数组已合并完，因此添加左子数组当前元素temp[i]，执行i=i+1
        - 否则，当temp[i]<=temp[j]时：添加左子数组当前元素temp[i]，并执行i=i+1
        - 否则（即temp[i]>temp[j]）时：添加右子数组当前元素temp[j]，并执行j=j+1；此时构成m-i+1个[逆序对]，统计添加至res。
4. **返回值**：返回直至目前的逆序对总数res


**时间复杂度***O(NlogN)*：其中*N*为数组长度；归并排序使用*O(NlogN)*时间
**空间复杂度***O(N)*：辅助数组temp占用*O(N)*大小的额外空间；
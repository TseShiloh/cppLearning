
# 手撕代码

## 快速排序
```cpp
#include <iostream>
#include <vector>
using namespace std;

int once_quickSort(vector<int>& data, int left, int right) {
	int key = data[left];// 先取出最左边的值作为[基准]
	while (left < right) {
		// [右哨兵]没有找到[较小值]，则[右哨兵]继续向左移动
		while (left < right && key <= data[right]) {
			right--;
		}
		// 此时key > data[right]，意味着[右哨兵]找到了比[基准]小的值，即data[right]要放在左边
		if (left < right) {
			data[left++] = data[right];// 用[较小值]占[基准]坑，完成后[左哨兵]向右移动一格
		}
		
		//[左哨兵]没有找到[较大值]，则[左哨兵]继续向右移动
		while (left < right && key >= data[left]) {
			left++;
		}
		// 此时key <= data[left]，意味着[左哨兵]找到了比[基准]大的值，即data[left]要放在右边
		if (left < right) {
			data[right--] = data[left];// 用[较大值]占原[较小值]的空坑，完成后[右哨兵]向左移动一格
		}
	}
	data[left] = key;// 此时剩下的空坑就是留给[基准]的位置，左边(右边)比[基准]小(大)
	return left;// 返回基准的位置
}

int quickSort(vector<int>& data, int left, int right) {
	if (left >= right) {
		return 1;
	}
	int middle = once_quickSort(data, left, right);// 返回上一次排序后的基准
	quickSort(data, left, middle-1);// 先对左边的数组进行递归
	quickSort(data, middle+1, right);// 再对右边的数组进行递归
}
```

## 快排练习
```cpp
#include <iostream>
#include <vector>
using namespace std;

int QuickSort_once(vector<int>& data, int left, int right) {
	int key = data[left];
	while (left < right) {
		while (left < right && data[right] >= key)
			right--;
		if (left < right)
			data[left++] = data[right];
		while (left < right && data[left] <= key)
			left++;
		if (left < right)
			data[right--] = data[left];
	}
	data[left] = key;
	return left;
}

int QuickSort(vector<int>& data, int left, int right) {
	if (left >= right)
		return 1;
	int middle = QuickSort_once(data, left, right);
	QuickSort(data, left, middle-1);
	QuickSort(data, middle+1, right);
}
```


# 八股文

## static的用法和意义
1. 修饰 变量
	- 静态变量存放在静态存储区
	- 局部静态变量的作用域在函数体中，全局静态变量的作用域在这个文件中。
2. 修饰 函数
	- 静态函数只能在本文件中使用
	- 不会和其他文件的同名函数冲突
3. 修饰 类
	- 静态成员：共用，不属于任何一个对象 ，通过类名（而不是对象名）访问。
	- 静态成员函数：同上；参数列表里面没有隐含this指针，不可以用const修饰静态成员函数；静态成员函数只能访问静态数据成员，不可以访问普通的数据成员。
	- 【补充】静态成员函数访问非静态成员时，要通过对象来引用

## const的用法（定义，用途）
1. 修饰 **类的成员变量**时
   - 表示常量不能被修改
2. 修饰 **类的成员函数**
   - 表示该函数不会修改类的数据成员
   - 不会调用其他非const的成员函数

## 解决哈希冲突的方式
1. 线性探查：逐个往后找
2. 二次探查：步长为i^2的往后找
3. 双散列函数法：当第一个散列函数发生冲突的时候，使用第二个散列函数进行哈希，作为步长。
4. 开链法：在每一个桶中维护一个链表(STL的hashtable就是采用这种实现方式)
5. 建立公共溢出区：发生冲突时，将所有冲突的数据放在公共溢出区。

## 测试开发的流程
需求分析→测试计划→测试设计→测试环境搭建→测试执行→测试记录→缺陷管理→软件评估→RTM
1. 需求分析
2. 测试计划
3. 测试设计
   - 测试用例编写
   - 测试场景设计 
4. 测试环境搭建
   - 针对不同架构（Client/Server,Brower/Server）
   - 针对不同操作系统 
5. 测试执行
   - 单元测试→集成测试→系统测试→出厂测试
   - 每个阶段还有回归测试  
6. 测试记录
7. 缺陷管理
8. 软件评估 
9. 测试总结
10. 测试维护
11. 流程分析
12. 

## 关系型数据库
保持数据的一致性
数据更新的开销较小
支持复杂查询

## 非关系型数据库的优点
不需要经过sql层的解析，读写效率高
基于键值对，数据的扩展性很好
可以支持多种类型数据的存储

## 非关系型数据库适用的场景
日志系统
地理位置存储
数据量巨大
高可用

## MySQL执行一挑查询语句的过程

连接器->缓存->分析器->优化器->执行器

- 连接器：客户端先通过连接器连接到MySQL服务器
- 缓存：连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器
- 分析器：分析器会对查询语句进行语法分析和词法分析，判断SQL语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。
- 优化器：优化器是对查询语句进行优化处理，例如一个表里有多个索引，优化器会判别哪个索引性能会更好
- 执行器：优化器执行完就运行执行器，执行器就开始执行语句进行查询比对，直至查询到满足条件的所有数据，然后执行返回


## 数据库的索引类型
分为**逻辑分类**和**物理分类**
1. 逻辑分类
- 主键索引：当关系表中定义主键时会自动创建主键索引。每张表的主键索引只能有一个，要求主键中的每个值都唯一，即不可重复，也不能有空值。
- 唯一索引：数据列不能有重复，可以有空值。一张表可以有多个唯一索引，但是每个唯一索引只能有系列，例如身份证
- 普通索引：一张表可以用多个普通索引，可以重复，可以为空值
- 全文索引：可以加快模糊查询，但不常用


2. 物理分类
- 聚集索引（聚簇索引）：数据在**物理存储中的顺序**跟索引中数据的**逻辑顺序相同**，比如以ID建立聚集索引，数据库中id从小到大排列，那么物理存储中该数据的内存地址值也按照从小到大存储。一般是表中的主键索引，如果没有主键索引就会以**第一个非空的唯一索引**作为聚集索引。一张表只能有一个聚集索引。
- 非聚集索引： 数据在**物理存储中的顺序**跟索引中数据的**逻辑顺序不同**。非聚集索引因为无法定位数据所在的行，所以需要扫描两边索引树。第一遍扫描非聚集索引的索引树，


## 优化MySQL
高频访问：
	- 分表分库：将数据库表进行水平拆分，减少表的长度
	- 增加缓存：在web和DB之间加上一层缓存层
	- 增加数据库的索引：在合适的字段加上索引，解决高频访问的问题
并发优化：
	- 主从读写分离：只从主服务器上写，从服务器读
	- 负载均衡集群：通过集群或者分布式的方式解决并发压力

## 什么时候上索引

1. 优点
经常搜索的列
作为主键上的列
经常需要连接（where子句）的列
经常需要排序的列
经常需要范围查找的列

2. 缺点
很少查询的列
更新很频繁的列
数据值的取值比较少的列

## 索引的底层实现
数据库的索引是使用B+树来实现的
- B+树是一种特殊的平衡多路树，是B树的改进版本
- 所有的数据都存放在叶节点上，中间节点保存的是索引
- 减少数据对中间节点的空间占用，使得中间节点可以存放更多的指针，树变得更矮，减少查询的磁盘IO次数，提高查询效率

## 数据库中事务的4大特性

1. 原子性 Atom
事务是一个不可分割的工作单位，全部发生or全都不发生

2. 一致性 Consistency
事务应该将数据从一个一致性状态转移到另一个一致性状态。
   
3. 隔离性 Isolation
隔离性要求数据库事务不会受到另一个并发执行的事务的影响。

4. 持久性 Durability
事务对数据库的改变是永久的，数据库损坏都不会影响到已发生的事务。

## 什么是脏读、不可重复读、幻读？

脏读：一个事务在处理过程中读取了另一个还没提交的事务的数据

不可重复读：对于数据库的某一个字段，一个事务多次查询却返回了不同的值，这是因为在查询的间隔中，该字段被另一个事务修改并提交了

幻读：事务多次读取同一个范围的时候，查询结果的记录数不一样，这是由于在查询的间隔中，另一个事务新增或删除了数据。

## 数据库的范式

第一范式：确保每列保持原子性
第二范式：确保表中的每列都和主键相关
第三范式：确保非主键的列没有传递依赖
BCNF范式：确保主键之间没有传递依赖

## 数据的锁的种类和加锁的方式
按照**类型**划分：乐观锁和悲观锁
根据**粒度**划分：行级锁 < 页级锁 < 表级锁
根据**作用**划分：共享锁（读锁）、排他锁（写锁）

## 乐观锁和悲观锁是怎么实现的
1. 悲观锁要求在整个过程中一直与数据库有一条连接，因为上一个事务完成后才能让下一个事务执行，这个过程是串行的。

- 悲观锁有行级锁和页级锁两种形式。
- 行级锁对正在使用的单条数据进行锁定，事务完成后释放该行数据；
- 页级锁对整张表进行锁定，事务正在对该表进行访问的时候不允许其他事务的并行访问。

2. 乐观锁
- 执行事务时把整个数据拷贝到应用中，在数据更新提交的时候比较数据库和新数据，如果两个数据一模一样则表示没有冲突可以直接提交，如果有冲突则交给业务逻辑解决
- 使用版本戳对数据进行标记，每发生一次修改，版本号就+1.某条数据在提交的时候，如果数据库中的版本号与自己的一致，就说明数据没有发生修改，否则就认为是过期数据需要处理。
- 最后一种采用时间戳对数据最后修改的时间进行标记。

## 什么是共享锁和排他锁
1. 共享锁是读操作的时候创建的锁，一个事务对数据加上共享锁之后，**其他事务只能对数据再加共享锁**，不能进行写操作直到释放所有共享锁。

2. 排他锁是写操作时创建的锁，事务对数据加上排他锁之后其他**任何事务都不能对数据加任何的锁**（即其他事务不能再访问该数据）



## 操作系统的内存管理
操作系统的内存管理包括物理内存管理和虚拟内存管理

物理内存管理：包括交换与覆盖，分页管理，分段管理和段页式管理等；
虚拟内存管理：包括虚拟内存的概念，页面置换算法，页面分配策略等；
# 进程
传统典型的定义：（==强调“动态性”==）
1. 进程是一个程序的**执行过程**，执行前==需要将该程序放到内存中==，才能被CPU处理。
2. 一个程序及其数据在处理机上顺序执行时所**发生的活动**
3. 具有独立功能的程序在数据集合上**运行的过程**，是系统进行资源分配和调度的一个独立单位。

程序：就是一个指令序列

进程实体（进程映像）：进程控制块(PCB)、程序段、数据段
- PCB是进程存在的**唯一标志**
- 因此进程也可定义为：
进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。

## 进程的三种基本状态
1. 运行态：处理机✓ 其他✓
2. 就绪态：处理机× 其他✓
3. 阻塞态：处理机× 其他×

另外的两个状态：
创建态：操作系统味新进程分配资源，创建PCB
终止态：操作系统回收进程的资源，撤销PCB

运行态->阻塞态 是一种进程自身做出的**主动**行为
阻塞态->就绪态 不是进程自身能控制的，是**被动**行为

## 进程控制
实现进程状态的转换

用原语实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成。
这种不可被中断的操作即原子操作。
原语采用“关中断指令”和“开中断指令”实现

阻塞原语和唤醒原语必须成对使用，因何事阻塞就应由何事唤醒。

## 进程通信
各进程拥有的内存地址空间相互独立，一个进程不能直接访问另一个进程的地址空间。

1. 共享存储（基于**数据结构 / 存储区**的共享）
两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现）

操作系统只负责提供共享空间和同步互斥工具（如P,V操作）
2. 管道通信
在内存中开辟一个大小固定的缓冲区
半双工、互斥   

# 并发性
## 互斥、同步
进程同步：协调多个进程的工作次序，进程之间的直接制约关系。

进程互斥：一个进程访问某**临界资源（一个时间段内只允许一个进程使用）**时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。
- 临界区：进程中访问临界资源的代码段
- 进入区：设置正在刚问临界资源都标志（上锁）
- 退出区：解锁。（进入区和退出区是负责实现互斥的代码段）
- 剩余区

进程互斥的一些原则：
1. 空闲让进。
2. 忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；
3. 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；
4. 让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待；

## 互斥的软件实现方法：
1. 单标志法
每个进程进入临界区的权限只能被另一个进程赋予。每个进程在退出区把临界区的使用权转交给另一个进程。
- 违背了“空闲让进”原则
2. 双标志先检查法
设置一个flag数组标记各进程想进入临界区的意愿，进程在进入区先**检查其他进程是否也有意愿**，后上锁，退出区解锁。
- 在“检查后，上锁前”有可能会发生进程切换，违背了“忙则等待”原则
3. 双标志后检查法
在自身对临界区进行上锁后，检查发现存在别的进程也有意愿（甚至也上了锁），从而进程之间都无法进入临界区。
- “先检查，后上锁”虽然满足了“忙则等待”原则，但是违背了“空闲让进”和“有限等待”原则，会出现个进程都长期无法访问临界资源而产生“饥饿”现象。
4. Peterson算法
表达自己想使用临界区的意愿，但同时又愿意让出临界区。
- 遵循了前三个原则，但是违背了“让权等待”的原则。


## 互斥的硬件实现方法
1. 中断屏蔽方法
- 使用“开/关中断”指令实现
- 只适用于单处理机；只适用于操作系统内核进程
2. TestAndSet指令
- old记录是否已被上锁；
- 再将lock设为true；
- 检查临界区是否已被上锁（若已上锁，则 循环重复前几步）
- 适用多处理机
- 不满足“让权等待”原则
3. Swap指令（XCHG指令） 
- 同上


## 信号量机制
整形信号量：用一个**整数型变量**作为信号量，用来**表示系统中某种资源的数量**。
- 不满足“让权等待”的原则
记录型信号量：用记录型数据结构表示信号量
- 对信号量S的**一次P操作**意味着进程**请求**一个单位的该类资源，因此需要执行S.value--，表示资源数量-1；如果S.value<0，表示该类资源已经分配完毕，则此进程应调用block原语进行自我阻塞（运行态->阻塞态），主动放弃处理机。
- 对信号量S的**一次V操作**意味着进程**释放**一个单位的该类资源，因此需要执行S.value++，表示资源数量+1；如果+1后S.value<=0，表示有进程在等待该类资源，调用wakeup原语唤醒队列中的第一个进程（阻塞态->就绪态）。

用信号量实现进程同步
1. 分析何处需要实现同步关系，保证“一前一后”执行的两个操作
2. 设置同步信号量S，初始为）
3. 在“前操作”之后执行V(S)
4. 在“后操作”之前执行P(S)

用信号量实现前驱关系
1. 为每一对前驱关系各设置一个同步变量
2. 同上步骤



# 管程 
用于实现同步和互斥
机制有点像“类”

组成结构：
1. 共享数据结构
2. 对数据结构初始化的语句
3. 一组用来访问数据结构的过程（函数）

基本特征：
1. 局部于管程的数据只能被局部于管程的过程所访问
2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
3. 每次==仅允许一个进程==在管程内执行某个内部过程。

# 线程
实现方式：用户级线程、内核级线程
线程是一个基本的CPU执行单元，也是程序执行流的最小单位。
引入线程之后，进程是资源分配的基本单位，线程是调度的基本单位。
- 线程几乎不拥有系统资源
- 由于共享内存地址空间，同一进程种的线程间通信甚至无需系统干预。
- 同一进程种的线程切换，不会引起线程切换
- 内核级线程才是处理机分配的单位



# 死锁
死锁：各个进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。
饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。
死循环：某进程执行过程种一直跳不出某个循环的现象。

区别：
- 两个以上的进程同时发生死锁。一定是处于阻塞态
- 可能只有一个进程发生饥饿。可能是阻塞态or就绪态
- 死锁和饥饿是操作系统的问题，死循环是被管理者的问题。可能处于运行态。


## 死锁的必要条件
1. 互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。
2. 不剥夺条件：不能由其他进程强行夺走，只能自己主动释放。
3. 请求和保持条件:进程已经保持了至少一个资源，但同时请求了新的资源，而该资源又被其他进程占有。
4. 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被下一个进程所请求。


## 死锁的处理策略
1. 预防死锁
（1）破坏互斥条件
- 将临界资源改造味可共享使用的资源（如SPOOLing技术）
（2）破坏不剥夺条件
- 方案1：申请的资源得到不到满足时，立即释放拥有的所有资源；
- 方案2：申请的资源被其他进程占用时，由操作系统协助剥夺（考虑优先级）
- 缺点：剥夺资源可能导致部分工作失效；反复申请和释放导致系统开销大；可能导致饥饿
（3）破坏请求和保持条件
- 运行前分配好所有需要的资源，之后一直保持
- 缺点：资源利用率低；可能导致饥饿
（4）破坏循环等待条件
- 给资源编号，必须按编号从小到大的顺序申请资源
- 缺点：不方便添加新设备；导致资源浪费；

2. 避免死锁
安全序列：系统按照这种序列分配资源，则每个进程都能顺利完成。

银行家算法
（1）检查此次申请是否超过了之前声明的最大需求数
（2）检查此时系统剩余的可用资源是否还能满足此次请求
（3）试分配，更改各数据结构
（4）用安全性算法检查此次分配是否会导致系统进入不安全状态




3. 死锁的检测和解除
检测：
两种结点：进程结点、资源结点
两种边：进程结点->资源结点（请求边）、资源结点->进程结点（分配边）


解除：
（1）资源剥夺法
挂起，并抢占它的资源
（2）撤销进程法（终止进程法）
强制撤销部分甚至全部死锁进程，并剥夺这些进程的资源。
（3）进程回退法
让一个或多个死锁进程回退到足以避免死锁的地步。



# 内存

指令中一般使用的是**逻辑地址（相对地址）**
P.s. 物理地址（绝对地址）

写程序到程序运行的过程：编辑源代码文件->编译->链接->装入
1. 编译：由源代码文件生成目标模块（高级语言“翻译”为机器语言）
2. 链接：由目标模块生成装入模块，链接后形成完整的逻辑地址
3. 装入：将装入模块装入内存，装入后形成物理地址

【链接】
链接的三种方式：
1. 静态链接：在程序运行之前，先将各目标模块及他们所需的库函数连接成一个完整的可执行文件（装入模块）之后不再拆开。
2. 装入时动态链接：将各目标模块装入内存时，边装入边链接
3. 运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接


【装入】
装入模块装入内存，需要对指令中的地址进行处理。有三种方式：
1. 绝对装入：在编译时，如果知道程序将放到内存中的哪个位置，**编译程序将产生绝对地址**的目标代码。
-  只适用于**单道程序环境**
-  程序中使用的绝对地址可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。
2. 静态重定位：将逻辑地址变换为物理地址（地址变换是在**装入时**一次完成的）
3. 动态重定位：装入时不会立即修改，而是推迟到**程序真正要执行时**才进行地址转换。
- 需要一个**重定位寄存器**
- 允许程序在内存中发生移动

## 内存管理
操作系统堆对内存管理的内容如下：
### 内存空间的分配和回收
#### 连续分配管理
（系统为用户进程分配的必须是一个**连续的内存空间**）
1. 单一连续分配：内存分为系统区和用户区，内存中**只能有一道用户程序**，独占整个用户区空间。
2. 固定分区分配：将整个用户空间划分为**若干个（相等/不等）固定大小的分区**，每个分区中只能装入一道作业。
3. 动态分区分配：根据进程的大小动态建立分区。没有内部碎片（分配给某进程的内存区域内有些没被用上），但有外部碎片（内存中空闲分区由于太小而难以利用）
- 动态分区分配算法
1. 首次适应算法：每次都从低地址开始查找，找到第一个能满足大小的空闲分区

2. 最佳适应算法：空闲分区按容量递增次序链接
- 缺点：每次都选最小的分区进行分配，会留下很多的内存块从而导致很多外部碎片。

3. 最坏适应算法：优先使用更大的分区
4. 邻近适应算法：由首次适应演变而来，每次从上次查找结束位置开始查找


#### 非连续分配管理
（系统为用户进程分配的必须是一个**离散的内存空间**）
1. 基本分页存储管理：将**内存空间**分成大小相等的分区，称为**页框**；将**用户进程的地址空间**分为与页框大小相等的区域，称为**页**。
- 页表寄存器：用于存放页表起始地址和页表长度
- 基本地址变换机构需要两次访问内存（先访问页表，再访问页表项对应的内存）
- 具有快表的地址变换机构，若快表命中则只需一次访存；未命中则两次访存。

【两级页表】
单级页表存在的问题：
- 所有的页表项都连续存放
- 没有必要让整个页表都常驻内存

页目录表：一级页号 二级页号 页内偏移量 
可以在页表项汇总添加一个标志位，用于表示该页面是都已经调入内存。若想访问的页面不在内存中，则产生缺页中断（内中断），然后将目标页面从外存调入内存。

若采用多级页表机制，则各级页表的大小不能超过一个页面。

N级页表访问一个逻辑地址的访存次数为N+1

2. 基本分段存储管理
（与分页最大的差别就是离散分配时所分配地址空间的基本单位不同）

结构：段号 段长度 段起始地址

按照程序自身逻辑关系划分为若干个段，每段从0开始编址。每个段在内存中占连续空间，但各段之间可以不相邻。

页是信息的物理单位，是系统上的需要和行为，对用户不可见。
段是信息的逻辑单位，对用户可见

分页的用户进程地址空间是一维的，只需给出一个记忆符即可表示一个地址
分段的用户进程地址空间是二维的，需要给吃段名和段内地址

分段更容易实现信息的共享和保护



3. 段页式存储管理
段页式的地址结构是二维的：段号 页表长度 页表存放块号

段页式访存的次数为3，引入快表机构后可以达到1.



#### 页面分配策略
驻留集：请求分页管理中给进程分配的物理块的集合
工作集：在某段时间间隔里，进程实际访问页面的集合
- 驻留集的大小一般不能小于工作集的大小

抖动（颠簸）现象：刚换出的又要换入，反之亦然。
原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够）

固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即**驻留集大小不变**
可变分配：先为每个进程分配一定数目的物理块，在进程运行期间可根据情况做适当的调整，即**驻留集大小可变**

局部置换：发生缺页时只能选进程自己的物理块进行置换
全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以讲别的进程持有的物理块置换到外存，再分配给缺页进程。

因此存在下面三中情况：固定分配局部置换、可变分配局部置换、可变分配全局置换

调页的位置：对换区、文件区
- 对换区足够大：运行将数据从文件区复制到对换区，之后所有的页面调入、调出都是在内存与对换区之间进行的。
- 对换区不够大：不会修改的数据每次都从文件区调入；会修改的数据调出到对换区，需要使用时再从对换区调入。
- UNIX方式：第一次使用的页面都从文件区调入；调出的页面都写回对换区，再次使用时从对换区调入。

预调页策略：根据局部性原理，一次调入若干个相邻的页面。主要用于进程的首次调入（运行前调入）。

请求调页策略：进程在运行期间才将所缺页时才将所缺页面调入内存


















### 对内存空间进行扩充
1. 覆盖：内存分为一个**固定区**（程序的常用段，调入内存后不再调出）和若干个**覆盖区**（程序的不常用段，用时调入，不用时调出）
- 覆盖是在同一个程序or进程中

2. 交换
将内存中的某些进程暂时换出外存，将外存中某些已具备运行条件的进程换入内存。
磁盘分为文件区和对换区，换出的进程在对换区。
- 交换是在不同进程（或作业）之间的

3. 虚拟存储
虚拟内存的**最大容量**：由计算机的地址结构（CPU寻址范围）确定
虚拟内存的**实际容量**：min（内存和外存容量之和，CPU寻址范围）

1. 请求调页功能：当访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存
- 页表机制：在基本分页的基础上添加了几个表项；状态位；访问字段；修改位；外存地址。
- 缺页中断机制（内中断）：当要访问的页面不存在时产生一个缺页中断，此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。
- 地址变换机构：找到页表项检查页面是否在内存当中；不在内存中则请求调页；内存空间不够则换出页面；页面调入内存后需要修改相应页表项。


2. 页面置换功能：内存空间不够时，将内存暂时用不到的信息换到外存
五种置换算法：
- 最佳置换算法(OPT)：淘汰“以后永不使用的页面”or“最长时间内不再被访问的页面”
- 先进先出置换算法(FIFO)：淘汰“最早进入内存的页面”
- 最近最久未使用置换算法(LRU)：用访问字段记录该页面自上次被访问以来所经历的时间t
- 时钟置换算法(OPT)：设置访问位，需要淘汰页面时检查访问位；如果访问位是0，该页换出；访问位是1，则将其置为0，暂不换出。最多需要两轮扫描
- 改进型时钟置换算法(OPT)：增加一个修改位，减少I/O操作。最多需要四轮扫描

### 地址转换功能

### 内存保护功能
1. 设置上下限寄存器
2. 利用重定位寄存器（存放起始物理地址）、界地址寄存器（存放最大逻辑地址）进行判断





# 调度
三个层次，从低到高：进程调度、内存调度、作业调度
1. 作业调度
选择一个或多个作业（作业是多个进程的集合）分配资源，建立相应的进程（PCB），以使他们获得竞争处理机的权利。

对进程状态的影响：无->创建态->就绪态

2. 内存调度
引入虚拟存储技术，可以将暂时不能运行的进程调至外存等待（**挂起状态**），但注意PCB不会一起调到外存，而是常驻内存。被挂起的进程的PCB会被放到挂起队列中。

对进程状态的影响：挂起态->就绪态（阻塞挂起->阻塞态）

3. 进程调度
选择一个进程为其分配处理机

对进程状态的影响：就绪态->运行态

## 挂起态与七状态模型
挂起状态:暂时调到外存等待的进程状态，又可细分为就绪挂起、阻塞挂起。

5状态模型：创建态、阻塞态、就绪态、运行态、终止态
7状态模型：多了就绪挂起和阻塞挂起

## 进程调度
1. 以下三个过程不能进行进程调度：
- 处理中断的过程中
- 操作系统内核程序临界区
- 原子操作过程中

2. 进程调度的方式
- 非剥夺调度（非抢占）方式：只允许进程主动放弃处理机 
- 剥夺调度（抢占）方式：由操作系统剥夺当前进程的CPU使用权


## 狭义的进程调度和进程切换的区别
广义的进程调度包含了调度和切换两个步骤。

狭义的进程调度：选中一个要运行的进程

进程切换：一个进程让出处理机，由另一个进程占用处理机。
1. 对原来运行进程各种数据的保存
2. 对新的进程各种数据的恢复


## 调度算法的评价指标
- CPU利用率
- 系统吞吐量
- 周转时间
- 等待时间
- 响应时间


## 调度算法
1. 先来先服务(FCFS, First Come First Serve)
- 非抢占式
2. 短作业优先(SPF, Shortest Process First)
- 非抢占式，但也有抢占式版本（最短剩余时间优先算法）
3. 高响应优先(HRRN, Highest Response Ratio Next)
- 非抢占式
- 响应比=(等待时间+要求服务时间)/要求服务时间
4. 时间片轮转
- 抢占式
- 时钟中断
5. 优先级
- 非抢占式/抢占式
6. 多级反馈队列
- 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
- 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还没结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾
- 只有第k级队列为空时，才会为k+1级队头的进程分配时间片


# 用户接口
1. 命令接口：允许用户**直接**使用
- 联机命令接口：用户说一句，系统做一句
- 脱机命令接口：用户说一堆，系统做一堆
2. 程序接口：允许用户通过程序**间接使用**
3. GUI(Graphical User Interface)：现代操作系统中最流行的图形用户接口
 
易混概念：系统调用=系统调用指令=广义指令

# 操作系统的特征
并发、共享、虚拟、异步

并发、共享：最基本的特征，二者互为存在条件

并发：多个事件在**同一时间间隔内**发生，宏观上是同时发生，微观上是交替发生的。
- 并行：多个事件在**同一时刻**同时发生 

共享：资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。
- 互斥共享：一个时间段内只允许一个进程访问该资源
- 同时共享：允许一个时间段内有多个进程“同时”访问该资源（微观上是交替的分时共享）

虚拟:把一个物理上的实体变为若干个逻辑上的对应物。前者是实际存在的，后者是用户感受到的。
- 空分复用技术（如虚拟存储技术）
- 时分复用技术（如虚拟处理器技术）

异步：多个程序并发执行，但资源有限，因此进程的执行并不是一贯到底的。

# 中断
1. 中断发生时，CPU立即进入**核心态**
2. 中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理
3. 对于不同的中断信号，会进行不同的处理。

**“用户态->核心态”** 是通过**中断**实现的，并且**中断**是**唯一途径**。
**“核心态->用户态”** 通过**执行一个特权指令**，将程序状态字（PSW）的标志位设置为“用户态”


# 文件管理
无结构文件：由一系列二进制或字符流组成

有结构文件：记录是一组相关数据项的集合；数据项是文件系统中最基本的数据单位。可分为下面三种：
1. 顺序文件
2. 索引文件
3. 索引顺序文件

顺序文件：文件中的文件一个接一个地顺序排列（逻辑上）
- 记录是定/可变长；各个记录在物理上是顺序/链式存储
- 可变长记录无法实现随机存取；定长记录可实现随机存取
- 记录是否按照关键字的顺序来排列，分为：串结构和顺序结构
- 串结构：记录之间的顺序与关键字无关，一般按照记录存入的时间决定记录的顺序
- 顺序结构：记录之间的顺序按关键字的顺序排列


索引文件：
- 索引表本身是定长记录的顺序文件
- 可以用不同的数据项建立多个索引表

索引顺序文件：一组记录对应一个索引表项
- 检索记录拾先顺序查索引表，找到分组，在顺序查找分组
- 可以建立多级索引表

## 文件目录
文件控制块（实现文件目录的关键数据结构）
索引节点（对文件控制块的优化）
绝对路径：从根目录出发

树形目录结构：不便于实现文件的共享
无环图目录结构：有向无环图；可以用不同的文件名指向同一个文件，甚至可以指向同一个目录。
- 可以为每个共享节点设置一个共享计数器。当用户提出删除结点时，只是删除该用户的FCB，并使共享计数器-1，只有共享计数器减为0时，才删除结点。

加入索引结点（除了文件名以外的描述信息都放这），这样目录只包含了“文件名”和“指向索引结点的指针”，这样目录项长度减小，因此磁盘块可以存放更多的目录项，检索文件时磁盘I/O的次数就少了很多。


## 文件的物理结构（文件的分配方式）
【连续分配】
每个文件（分成逻辑块）在磁盘上占有一组**连续**的块（物理块）。因此支持**顺序访问**和**直接（随机）访问**
- 不方便拓展，需要整体迁移，磁盘开销很大
- 存储空间利用率低，会产生难以利用的磁盘碎片，可用紧凑来处理，但需要耗费时间。

【链接分配】
采取**离散**分配的方式，分为隐式链接和显式链接。
1. 隐式链接
格式：文件名    ……  起始块号    结束块号
- 只支持顺序访问，不支持随机访问
- 方便拓展，不会有碎片问题，外存利用率高

2. 显式链接
把用于链接文件各物理块的指针显式地存放在一张表中，即文件分配表(FAT, File Allocation Table)
- 一张磁盘仅设一张FAT，开机时将FAT读入内存并常驻内存。
- FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的。
- 支持随机访问；地址转换时不需要访问磁盘（查FAT表就行）；

【索引分配】
系统会为每个文件建立一张索引表，索引表记录了文件的各个逻辑块对应的物理块
- 索引块：存放索引表的磁盘块
- 数据块：存放文件数据的磁盘块
- 支持随机访问

1. 链接方案
2. 多层索引（类似于多级页表）
3. 混合索引（包含直接地址索引、一级间接索引、二级间接索引）


## 文件存储空间管理
将文件磁盘划分为一个个文件卷（逻辑卷、逻辑盘）
存储空间的初始化将各个文件卷划分为目录区、文件区

1. 空闲表法
表格式: 第一个空闲盘块号  空闲盘块数
- 回收时需要注意表项的合并问题（根据回收区和相邻空闲区之间的关系）
2. 空闲链表法
- 空闲盘块链：以盘块为单位组成一条空闲链；空闲盘块中存储着下一个空闲盘块的指针。
- 空闲盘区链：以盘区（连续的空闲盘块）为单位；空闲盘区中的第一个盘块内记录了盘区的长度和下一个盘区的指针。
3. 成组链接法
文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存，并且要保证内存和外存中的“超级块”数据一致。
- 超级块记录了**下一组空闲盘块的数量**和**这组空闲盘块的块号**




# 设备管理